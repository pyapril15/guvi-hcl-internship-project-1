"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/utils/api.ts":
/*!**************************!*\
  !*** ./app/utils/api.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   calculatorApi: () => (/* binding */ calculatorApi)\n/* harmony export */ });\n// utils/api.ts\nconst API_BASE_URL = \"http://localhost:3006/api\" || 0;\nclass ApiError extends Error {\n    constructor(status, message){\n        super(message), this.status = status;\n        this.name = 'ApiError';\n    }\n}\nconst handleResponse = async (response)=>{\n    const contentType = response.headers.get('content-type');\n    if (!contentType || !contentType.includes('application/json')) {\n        throw new ApiError(response.status, 'Server returned non-JSON response');\n    }\n    const data = await response.json();\n    if (!response.ok) {\n        throw new ApiError(response.status, data.message || \"HTTP \".concat(response.status, \": Request failed\"));\n    }\n    if (!data.success) {\n        throw new ApiError(response.status, data.message || 'API request was not successful');\n    }\n    return data.data;\n};\nconst createFetchWithTimeout = function() {\n    let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10000;\n    return function(url) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return Promise.race([\n            fetch(url, options),\n            new Promise((_, reject)=>setTimeout(()=>reject(new Error('Request timeout')), timeout))\n        ]);\n    };\n};\nconst fetchWithTimeout = createFetchWithTimeout(10000); // 10 second timeout\nconst calculatorApi = {\n    async saveCalculation (calculation) {\n        try {\n            const response = await fetchWithTimeout(\"\".concat(API_BASE_URL, \"/calculations\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(calculation)\n            });\n            return await handleResponse(response);\n        } catch (error) {\n            if (error instanceof ApiError) {\n                throw error;\n            }\n            // Network error or other issues\n            console.error('Save calculation error:', error);\n            throw new ApiError(0, 'Network error: Unable to save calculation. Please check your connection.');\n        }\n    },\n    async getCalculations () {\n        try {\n            const response = await fetchWithTimeout(\"\".concat(API_BASE_URL, \"/calculations\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            return await handleResponse(response);\n        } catch (error) {\n            if (error instanceof ApiError) {\n                throw error;\n            }\n            // Network error or other issues\n            console.error('Get calculations error:', error);\n            throw new ApiError(0, 'Network error: Unable to fetch calculations. Please check your connection.');\n        }\n    },\n    async checkHealth () {\n        try {\n            const response = await fetchWithTimeout(\"\".concat(API_BASE_URL, \"/health\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (response.ok) {\n                const data = await response.json();\n                return data.success === true;\n            }\n            return false;\n        } catch (error) {\n            console.error('Health check error:', error);\n            return false;\n        }\n    },\n    async deleteAllCalculations () {\n        try {\n            const response = await fetchWithTimeout(\"\".concat(API_BASE_URL, \"/calculations\"), {\n                method: 'DELETE',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            return await handleResponse(response);\n        } catch (error) {\n            if (error instanceof ApiError) {\n                throw error;\n            }\n            console.error('Delete all calculations error:', error);\n            throw new ApiError(0, 'Network error: Unable to delete calculations. Please check your connection.');\n        }\n    },\n    async deleteCalculationById (id) {\n        try {\n            const response = await fetchWithTimeout(\"\".concat(API_BASE_URL, \"/calculations/\").concat(id), {\n                method: 'DELETE',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            return await handleResponse(response);\n        } catch (error) {\n            if (error instanceof ApiError) {\n                throw error;\n            }\n            console.error('Delete calculation error:', error);\n            throw new ApiError(0, 'Network error: Unable to delete calculation. Please check your connection.');\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0csT0FBTyxLQUFLO1lBQzVCO1lBQ0EsT0FBTztRQUNYLEVBQUUsT0FBT21CLE9BQU87WUFDWkMsUUFBUUQsS0FBSyxDQUFDLHVCQUF1QkE7WUFDckMsT0FBTztRQUNYO0lBQ0o7SUFFQSxNQUFNSTtRQUNGLElBQUk7WUFDQSxNQUFNL0IsV0FBVyxNQUFNbUIsaUJBQWlCLEdBQWdCLE9BQWI3QixjQUFhLGtCQUFnQjtnQkFDcEVpQyxRQUFRO2dCQUNSckIsU0FBUztvQkFDTCxnQkFBZ0I7Z0JBQ3BCO1lBQ0o7WUFFQSxPQUFPLE1BQU1ILGVBQXlDQztRQUMxRCxFQUFFLE9BQU8yQixPQUFPO1lBQ1osSUFBSUEsaUJBQWlCakMsVUFBVTtnQkFDM0IsTUFBTWlDO1lBQ1Y7WUFDQUMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsTUFBTSxJQUFJakMsU0FBUyxHQUFHO1FBQzFCO0lBQ0o7SUFFQSxNQUFNc0MsdUJBQXNCQyxFQUFVO1FBQ2xDLElBQUk7WUFDQSxNQUFNakMsV0FBVyxNQUFNbUIsaUJBQWlCLEdBQWdDYyxPQUE3QjNDLGNBQWEsa0JBQW1CLE9BQUgyQyxLQUFNO2dCQUMxRVYsUUFBUTtnQkFDUnJCLFNBQVM7b0JBQ0wsZ0JBQWdCO2dCQUNwQjtZQUNKO1lBRUEsT0FBTyxNQUFNSCxlQUErQkM7UUFDaEQsRUFBRSxPQUFPMkIsT0FBTztZQUNaLElBQUlBLGlCQUFpQmpDLFVBQVU7Z0JBQzNCLE1BQU1pQztZQUNWO1lBQ0FDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO1lBQzNDLE1BQU0sSUFBSWpDLFNBQVMsR0FBRztRQUMxQjtJQUNKO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxweXR3bFxcRG93bmxvYWRzXFwzNGQ5ZDhmMS1lZjIxLTQ1YTAtOTRjNi0yNmJmMzNkOGNmODBfNFxcYXBwXFx1dGlsc1xcYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHV0aWxzL2FwaS50c1xyXG5pbXBvcnQge0FwaVJlc3BvbnNlLCBDYWxjdWxhdGlvblJlY29yZCwgQ3JlYXRlQ2FsY3VsYXRpb25SZXF1ZXN0fSBmcm9tICcuLi90eXBlcy9jYWxjdWxhdGlvbic7XHJcblxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDYvYXBpJztcclxuXHJcbmV4cG9ydCBjbGFzcyBBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBzdGF0dXM6IG51bWJlciwgbWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgaGFuZGxlUmVzcG9uc2UgPSBhc3luYyA8VD4ocmVzcG9uc2U6IFJlc3BvbnNlKTogUHJvbWlzZTxUPiA9PiB7XHJcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcclxuXHJcbiAgICBpZiAoIWNvbnRlbnRUeXBlIHx8ICFjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKHJlc3BvbnNlLnN0YXR1cywgJ1NlcnZlciByZXR1cm5lZCBub24tSlNPTiByZXNwb25zZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGE6IEFwaVJlc3BvbnNlPFQ+ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCBkYXRhLm1lc3NhZ2UgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiBSZXF1ZXN0IGZhaWxlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKHJlc3BvbnNlLnN0YXR1cywgZGF0YS5tZXNzYWdlIHx8ICdBUEkgcmVxdWVzdCB3YXMgbm90IHN1Y2Nlc3NmdWwnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YS5kYXRhO1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlRmV0Y2hXaXRoVGltZW91dCA9ICh0aW1lb3V0OiBudW1iZXIgPSAxMDAwMCkgPT4ge1xyXG4gICAgcmV0dXJuICh1cmw6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xyXG4gICAgICAgICAgICBmZXRjaCh1cmwsIG9wdGlvbnMpLFxyXG4gICAgICAgICAgICBuZXcgUHJvbWlzZTxSZXNwb25zZT4oKF8sIHJlamVjdCkgPT5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0JykpLCB0aW1lb3V0KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgXSk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGNyZWF0ZUZldGNoV2l0aFRpbWVvdXQoMTAwMDApOyAvLyAxMCBzZWNvbmQgdGltZW91dFxyXG5cclxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0b3JBcGkgPSB7XHJcbiAgICBhc3luYyBzYXZlQ2FsY3VsYXRpb24oY2FsY3VsYXRpb246IENyZWF0ZUNhbGN1bGF0aW9uUmVxdWVzdCk6IFByb21pc2U8Q2FsY3VsYXRpb25SZWNvcmQ+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoYCR7QVBJX0JBU0VfVVJMfS9jYWxjdWxhdGlvbnNgLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNhbGN1bGF0aW9uKSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlUmVzcG9uc2U8Q2FsY3VsYXRpb25SZWNvcmQ+KHJlc3BvbnNlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcGlFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTmV0d29yayBlcnJvciBvciBvdGhlciBpc3N1ZXNcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignU2F2ZSBjYWxjdWxhdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBcGlFcnJvcigwLCAnTmV0d29yayBlcnJvcjogVW5hYmxlIHRvIHNhdmUgY2FsY3VsYXRpb24uIFBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhc3luYyBnZXRDYWxjdWxhdGlvbnMoKTogUHJvbWlzZTxDYWxjdWxhdGlvblJlY29yZFtdPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KGAke0FQSV9CQVNFX1VSTH0vY2FsY3VsYXRpb25zYCwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlUmVzcG9uc2U8Q2FsY3VsYXRpb25SZWNvcmRbXT4ocmVzcG9uc2UpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFwaUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBOZXR3b3JrIGVycm9yIG9yIG90aGVyIGlzc3Vlc1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHZXQgY2FsY3VsYXRpb25zIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKDAsICdOZXR3b3JrIGVycm9yOiBVbmFibGUgdG8gZmV0Y2ggY2FsY3VsYXRpb25zLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYXN5bmMgY2hlY2tIZWFsdGgoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KGAke0FQSV9CQVNFX1VSTH0vaGVhbHRoYCwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zdWNjZXNzID09PSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdIZWFsdGggY2hlY2sgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhc3luYyBkZWxldGVBbGxDYWxjdWxhdGlvbnMoKTogUHJvbWlzZTx7IGRlbGV0ZWRDb3VudDogbnVtYmVyIH0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoYCR7QVBJX0JBU0VfVVJMfS9jYWxjdWxhdGlvbnNgLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVSZXNwb25zZTx7IGRlbGV0ZWRDb3VudDogbnVtYmVyIH0+KHJlc3BvbnNlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcGlFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRGVsZXRlIGFsbCBjYWxjdWxhdGlvbnMgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoMCwgJ05ldHdvcmsgZXJyb3I6IFVuYWJsZSB0byBkZWxldGUgY2FsY3VsYXRpb25zLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYXN5bmMgZGVsZXRlQ2FsY3VsYXRpb25CeUlkKGlkOiBudW1iZXIpOiBQcm9taXNlPHsgaWQ6IG51bWJlciB9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KGAke0FQSV9CQVNFX1VSTH0vY2FsY3VsYXRpb25zLyR7aWR9YCwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlUmVzcG9uc2U8eyBpZDogbnVtYmVyIH0+KHJlc3BvbnNlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcGlFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRGVsZXRlIGNhbGN1bGF0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKDAsICdOZXR3b3JrIGVycm9yOiBVbmFibGUgdG8gZGVsZXRlIGNhbGN1bGF0aW9uLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn07Il0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQXBpRXJyb3IiLCJFcnJvciIsInN0YXR1cyIsIm1lc3NhZ2UiLCJuYW1lIiwiaGFuZGxlUmVzcG9uc2UiLCJyZXNwb25zZSIsImNvbnRlbnRUeXBlIiwiaGVhZGVycyIsImdldCIsImluY2x1ZGVzIiwiZGF0YSIsImpzb24iLCJvayIsInN1Y2Nlc3MiLCJjcmVhdGVGZXRjaFdpdGhUaW1lb3V0IiwidGltZW91dCIsInVybCIsIm9wdGlvbnMiLCJQcm9taXNlIiwicmFjZSIsImZldGNoIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJmZXRjaFdpdGhUaW1lb3V0IiwiY2FsY3VsYXRvckFwaSIsInNhdmVDYWxjdWxhdGlvbiIsImNhbGN1bGF0aW9uIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJnZXRDYWxjdWxhdGlvbnMiLCJjaGVja0hlYWx0aCIsImRlbGV0ZUFsbENhbGN1bGF0aW9ucyIsImRlbGV0ZUNhbGN1bGF0aW9uQnlJZCIsImlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/api.ts\n"));

/***/ })

});